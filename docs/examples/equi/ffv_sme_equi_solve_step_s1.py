# -*- coding: utf-8 -*-
"""
Testing solving for relative optimal equilibrium prices and quantities in labor market model
============================================================================================

Part 1 of https://github.com/FanWangEcon/PrjLECM/issues/4


"""

import numpy as np
import prjlecm.equi.cme_equi_solve as cme_equi_solve
import prjlecm.util.cme_supt_misc as cme_supt_misc

np.set_printoptions(precision=8, suppress=True)

# %%
# Solve for I=1 worker types, and J=4 occupations
# ======================================================================
# Given the following "intr" = intercept and "slpe" = slope parameters
# for "sprl" = supply relative and "dmrl" = demand relative functions
# We solve for the equilibrium relative prices and quantities
#
# In Step 1, we solve for equilibrium relative quantities and prices, all within-worker-type relative
# optimality of the jth occupation to the 1st occupation for the ith worker.
#
# These correspond to what is written in Part 1 of https://github.com/FanWangEcon/PrjLECM/issues/4:
#
# - Supply intercept difference, `mt_sprl_wthn_i_acrs_jv1_intr`: :math:`\alpha_{i,j} - \alpha_{i,1}`
# - Supply slope, `mt_sprl_wthn_i_acrs_jv1_slpe`: :math:`\beta`
# - Demand intercept, `mt_dmrl_wthn_i_acrs_jv1_intr`: :math:`\left(\frac{1}{1-\psi}\cdot \ln \left( \frac{\theta_{i,j}}{\theta_{i,1}}\right)\right)`
# - Demand slope, `mt_dmrl_wthn_i_acrs_jv1_slpe`: :math:`-\frac{1}{1-\psi}`
#
# Random values for these could be generated by `cme_equi_solve_gen_inputs.cme_equi_supply_dict_converter_nonest()`.
# There is one worker type (I=1) and four occupations (J=4). There are
# 3 columns, because occupation 1 is the base occupation, and we are solving
# for relative prices (wages) and quantities for occupations 2, 3, and 4 relative to
# occupation 1.
#
# In calling `cme_equi_solve.cme_equi_solve_sone()`, we generate two outputs:
#
# - `mt_eqrl_wage_wthn_i_acrs_jv1`: relative equilibrium wages, :math:`\ln\left(\frac{W_{i,j}}{W_{i,1}})\right)`
# - `mt_eqrl_qnty_wthn_i_acrs_jv1`: relative equilibrium quantities, :math:`\ln\left(\frac{L_{i,j}}{L_{i,1}}\right)`
#
# Expected output:
# {
#     'mt_eqrl_wage_wthn_i_acrs_jv1':
#         np.array([[0.63118508, 0.64198258, 0.28607947]]),
#     'mt_eqrl_qnty_wthn_i_acrs_jv1':
#         np.array([[-2.56447086, -2.97421994, -0.87655583]])
# }

dc_sprl_intr_slpe = {
    "mt_sprl_wthn_i_acrs_jv1_intr": np.array(
        [
            [-2.87230895, -3.28732412, -1.01608092],
        ]
    ),
    "mt_sprl_wthn_i_acrs_jv1_slpe": np.array(
        [
            [0.48771445, 0.48771445, 0.48771445],
        ]
    ),
}

dc_dmrl_intr_slpe = {
    "mt_dmrl_wthn_i_acrs_jv1_intr": np.array([[-1.50007678, -1.89161757, -0.39412793]]),
    "mt_dmrl_wthn_i_acrs_jv1_slpe": np.array([[-1.68634227, -1.68634227, -1.68634227]]),
}

dc_equi_solve_sone = cme_equi_solve.cme_equi_solve_sone(
    dc_sprl_intr_slpe, dc_dmrl_intr_slpe, verbose=False
)

# Usage
cme_supt_misc.print_dict_aligned(dc_equi_solve_sone)

# %%
# Solve for I=3 worker types, and J=4 occupations
# ======================================================================
# Results are independent across worker types, so we get the same result from the first
# row below as we did in the prior call with only first row (worker type 1) information
#
# Expected Output:
# {
#     'mt_eqrl_wage_wthn_i_acrs_jv1':
#         np.array([[ 0.63118508,  0.64198258,  0.28607947],
#                   [ 0.56202092, -0.62270413,  0.07590281],
#                   [ 0.12807774,  0.18244942, -0.47797888]]),
#     'mt_eqrl_qnty_wthn_i_acrs_jv1':
#         np.array([[-2.56447086, -2.97421994, -0.87655583],
#                   [-1.84302116,  1.57255261, -0.21120755],
#                   [-0.56027346, -0.87677284,  1.50758174]])
# }

dc_sprl_intr_slpe = {
    "mt_sprl_wthn_i_acrs_jv1_intr": np.array(
        [
            [-2.87230895, -3.28732412, -1.01608092],
            [-2.07453757, 1.8290666, -0.24247462],
            [-0.62170068, -0.9642772, 1.73682464],
        ]
    ),
    "mt_sprl_wthn_i_acrs_jv1_slpe": np.array(
        [
            [0.48771445, 0.48771445, 0.48771445],
            [0.41193558, 0.41193558, 0.41193558],
            [0.47960885, 0.47960885, 0.47960885],
        ]
    ),
}

dc_dmrl_intr_slpe = {
    "mt_dmrl_wthn_i_acrs_jv1_intr": np.array(
        [
            [-1.50007678, -1.89161757, -0.39412793],
            [-0.89526152, 0.52246031, -0.08320943],
            [-0.34429055, -0.56910067, 0.70154576],
        ]
    ),
    "mt_dmrl_wthn_i_acrs_jv1_slpe": np.array(
        [
            [-1.68634227, -1.68634227, -1.68634227],
            [-1.68634227, -1.68634227, -1.68634227],
            [-1.68634227, -1.68634227, -1.68634227],
        ]
    ),
}

dc_equi_solve_sone = cme_equi_solve.cme_equi_solve_sone(
    dc_sprl_intr_slpe, dc_dmrl_intr_slpe, verbose=False
)

# Usage
cme_supt_misc.print_dict_aligned(dc_equi_solve_sone)

# %%
