# Solving demand side problem, focused on evaluating nested-CES outputs and derivatives
import pprint

import numpy as np

import prjlecm.equa.cme_supt_equa_demand as cme_supt_equa_demand
import prjlecm.input.cme_inpt_parse as cme_inpt_parse


def cme_prod_ces_nest_output(dc_ces_flat, verbose=False, verbose_debug=False):
    """Evaluates nested-CES production function 

    Given quantities solved or simulated stored at bottom-most layer
    in `dc_ces_flat` flat nested-ces storage nested-dictionary, generate
    all upper level quantities, with share and quantity parameters for 
    each sub-tree given information among children along each sub-branch. 
    Do this iteratively up until reach to top of the nesting tree. 

    Note that this will mute `dc_ces_flat` the input, not doing deepcopy.

    # Output for nested-CES problems
    # 1. Simulate nested-ces with quantities
    # 2. Find the index for the "highest"/bottom-most layer
    # 3. Find all the unique parents within the layer
    # 4. Conditional on layer and key, get Q array, and share Array
    # 5. Get from parent's dictionary power
    # 6. aggregate using cme_prod_ces
    # 7. continue with higher layer levels

    Parameters
    ----------
    dc_ces_flat : _type_
        Generated by cme_simu_demand.cme_simu_demand_params_ces_nested() 
    verbose : bool, optional
        Print outputs, by default True
    verbose_debug : bool, optional
        Print solution details, by default True
    """
    # 1. Get all layers
    it_max_layer, __, __ = cme_inpt_parse.cme_parse_demand_tbidx(
        dc_ces_flat)
    if verbose_debug:
        print(f'{it_max_layer=}')

    # 2. Loop over layers
    for it_layer_minus1 in reversed(np.arange(it_max_layer)):
        if verbose_debug:
            print(f'{it_layer_minus1+1=}')

        # 3. Find all the unique parents within the layer
        # does not need to be sorted
        ls_prt_layer = [dc_ces_flat[chd_key]['prt']
                        for chd_key in dc_ces_flat
                        if dc_ces_flat[chd_key]['lyr'] == (it_layer_minus1 + 1)]
        ls_it_unique_prt_layer = list(set(ls_prt_layer))
        if verbose_debug:
            print(f'{ls_it_unique_prt_layer=}')

        # 4. Conditional on layer and key, get Q array, and share Array
        # 5. Get from parent's dictionary power
        for it_prt_key in ls_it_unique_prt_layer:
            dc_parent = dc_ces_flat[it_prt_key]
            fl_pwr = dc_parent['pwr']
            ar_it_ipt = dc_parent['ipt']

            ar_shr = np.array([])
            ar_qty = np.array([])
            for it_chd_key in ar_it_ipt:
                dc_child = dc_ces_flat[it_chd_key]
                ar_shr = np.append(ar_shr, dc_child['shr'])
                ar_qty = np.append(ar_qty, dc_child['qty'])

            if verbose_debug:
                print(f'{it_prt_key=} and {ar_it_ipt=}')
                print(f'{ar_shr=}')
                print(f'{ar_qty=}')
                print(f'{fl_pwr=}')

            # 6. aggregate using cme_prod_ces
            # Generate output
            fl_qty_parent = cme_supt_equa_demand.cme_prod_ces(
                fl_elas=fl_pwr, ar_share=ar_shr, ar_input=ar_qty)
            # store output
            dc_ces_flat[it_prt_key]['qty'] = fl_qty_parent

    # Print
    if verbose:
        print('d-36197 name: dc_ces_flat')
        pprint.pprint(dc_ces_flat, width=2)

    return dc_ces_flat


def cme_prod_ces_nest_mpl(dc_ces_flat, verbose=False, verbose_debug=False):
    """Generate DRC and SHC for ces-nested flat 

    DRC = derivative cumulative, which is MPK
    SHC = share cumulative, which is share parameter if elas of sub all layer is homogeneous

    Without quantities at highest layer (bottom layer), only generates shc, 
    which is needed for equi. solution first iteration to generate highest
    layer optimal quantities. 

    With quantities at highest layer, randomly simulated for testing, or results
    of first iteration equilibrium solution, will generate derivative-based
    components for relative share (intercept term) from MRS vs relative wage
    equations. 

    Assume that we have already:
    a. Solved for some optimal equilibrium quantities at the bottom layer:
      - This means having called cme_solve.cme_equi_solve()
    b. Evaluated all nest level "aggregate" qs.
      - This means having called cme_solve_demand_eval.cme_prod_ces_nest()
    Note the CES derivative structure is, we are abusing notations, now indexing children within layer:
      y0 = (a_1 ( y1 )^{b_1} + ... )^(1/b_1)
      y1 = (a_2 ( y2 )^{b_2} + ... )^{1/b_2}
      y2 = (a_3 ( y3 )^{b_3} + ... )^{1/b_3}
      and corresponding derivatives are:
      dy0/dy1 = (1/b_1) * (a_1 ( y1 )^{b_1} + ... )^(1/b_1 - 1) * (a_1 * b_1 * (y1)^{b_1 - 1} )
      dy1/dy2 = (1/b_2) * (a_2 ( y2 )^{b_2} + ... )^(1/b_2 - 1) * (a_2 * b_2 * (y2)^{b_2 - 1} )
      dy2/dy3 = (1/b_3) * (a_3 ( y3 )^{b_3} + ... )^(1/b_3 - 1) * (a_3 * b_3 * (y3)^{b_3 - 1} )
      simplifying, we have:
      layer 1 nodes: dy0/dy1 = (1/b_1) * (y0)^(1-b_1) * (a_1 * b_1 * (y1)^{b_1 - 1} )
                             = (y0)^(1-b_1) * a_1 * (y1)^{b_1 - 1}
      layer 2 nodes: dy1/dy2 = (1/b_2) * (y1)^(1-b_2) * (a_2 * b_2 * (y2)^{b_2 - 1} )
                             = (y1)^(1-b_2) * a_2 * (y2)^{b_2 - 1}
      layer 3 nodes: dy2/dy3 = (1/b_3) * (y2)^(1-b_3) * (a_3 * b_3 * (y3)^{b_3 - 1} )
                             = (y2)^(1-b_3) * a_3 * (y3)^{b_3 - 1}
      Combining together, we have:
          (y0)^(1-b_1) * a_1 * (y1)^{b_1 - 1} * (y1)^(1-b_2) * a_2 * (y2)^{b_2 - 1} * (y2)^(1-b_3) * a_3 * (y3)^{b_3 - 1}
      If b_1 = b_2 = b_3 = b, we have:
          (y0)^{1-b} * a_1 * (y1)^{b - 1} * (y1)^(1-b) * a_2 * (y2)^{b - 1} * (y2)^(1-b) * a_3 * (y3)^{b - 1}
           = (y0)^{1-b} * a_1 * a_2 * a_3 * (y3)^{b - 1}
      We are interested in relative MPL, so we will divide the equation above from two 3rd layer input choices.
      Note that there are three components in the equation above:
          1. (y0)^{1-b}: this will be canceled out for MRS division, since it is shared by all inputs
          2. a_1 * a_2 * a_3: this becomes a part of the intercept term contribution from this input
          3. (y3)^{b - 1}: this becomes a part of the slope x log (labor ratio) on the right hand side
      Note that for the equation above, we are computing at the nodes corresponding to
      the denominator of the derivative, also note that, we need: (1) current node q;
      (2) parent node q; (3) current node share; (4) parent node power.
    Now we proceed to do the following:
    Overall, we construct:
      - drc: which is MPL for the current input at the current layer
      - drv: which is the contribution of the node at the current layer to the cumulative MPL
      - shr: this is already there, this is the share parameter for the current node at current layer
      - shc: this is the cumulative prod share parameters, from this point up a_1 * a_2 * ..., multiplied
      - sni: s=share n=nest i=intercept, this is the nested-ces intercept share parameter
             sni = drc/(y3)^{b3-1}, because (y3)^{b3-1} is slope component not intercept.
    1. At each non-0 layer, get the parent index
    2. Get the q and power parameter from the parent, also parent drc is lyr != 0
    3. For the current node, get its q and share
    4. Construct the derivative component, as drv, following:
      - (1/b_1) * (y0)^(1-b_1) * (a_1 * b_1 * (y1)^{b_1 - 1} )
    5. Take the product of drv with parent drc, store as drc, if lyr == 0, drc = drv
    6. When solving nested problems, initial round use share for share, later use drc for share.

    Parameters
    ----------
    dc_ces_flat : _type_
        _description_
    """

    # 0. Get all layers
    it_max_layer, __, it_lyr0_key = cme_inpt_parse.cme_parse_demand_tbidx(
        dc_ces_flat)
    if verbose_debug:
        print(f'{it_lyr0_key=} and {it_max_layer=}')

    # 1. lyr=0, drc set to 1
    dc_ces_flat[it_lyr0_key]['drc'] = 1
    dc_ces_flat[it_lyr0_key]['shc'] = 1
    dc_ces_flat[it_lyr0_key]['sni'] = 1

    # 2. Loop over layers, excluding 0th
    for it_layer in np.arange(it_max_layer) + 1:
        if verbose_debug:
            print(f'{it_layer=}')

        # 3. Find all the unique parents within the layer
        # does not need to be sorted
        ls_prt_layer = [dc_ces_flat[chd_key]['prt']
                        for chd_key in dc_ces_flat
                        if dc_ces_flat[chd_key]['lyr'] == (it_layer)]
        ls_it_unique_prt_layer = list(set(ls_prt_layer))
        if verbose_debug:
            print(f'{ls_it_unique_prt_layer=}')

        # 4. Loop over parent key, and get parent q and power
        for it_prt_key in ls_it_unique_prt_layer:
            dc_parent = dc_ces_flat[it_prt_key]
            fl_prt_pwr = dc_parent['pwr']
            ar_it_ipt = dc_parent['ipt']
            # This line differs from cme_prod_ces_nest():
            fl_prt_qty = dc_parent['qty']
            fl_prt_drc = dc_parent['drc']
            fl_prt_shc = dc_parent['shc']

            if verbose_debug:
                print(f'{it_prt_key=} and {ar_it_ipt=}')

            # These below differ from cme_prod_ces_nest():
            for it_chd_key in ar_it_ipt:
                dc_child = dc_ces_flat[it_chd_key]
                fl_chd_shr = dc_child['shr']
                fl_chd_qty = dc_child['qty']

                # Cumulative share can be computied without qty
                # shc: sh(share)c(cumulative) Cumulative share only
                fl_chd_shc = fl_prt_shc * fl_chd_shr

                if fl_prt_qty is None:
                    # this means we are initializing shc
                    # have not solved equilibrium for first time yet
                    # no quantities
                    fl_chd_drv = None
                    fl_chd_drc = None
                    fl_chd_sni = None

                    if verbose_debug:
                        print(
                            f'{fl_chd_shr=:.4f} and {fl_chd_shc=:.4f}')
                else:
                    # Compute: (1/b_1) * (y0)^(1-b_1) * (a_1 * b_1 * (y1)^{b_1 - 1} )
                    # simplified:  (y0)^(1-b_1) * (a_1 * (y1)^{b_1 - 1} )
                    fl_chd_drv, fl_chd_drc, fl_chd_drv_p1 = cme_supt_equa_demand.cme_prod_ces_deri(
                        fl_prt_qty, fl_prt_pwr, fl_chd_shr, fl_chd_qty, fl_prt_drc)
                    if it_layer == 1:
                        fl_chd_drv_p1_layer_1 = fl_chd_drv_p1

                    # # part 1: (y0)^(1-b_1)
                    # fl_chd_drv_p1 = (fl_prt_qty)**(1-fl_prt_pwr)
                    # if it_layer == 1:
                    #     fl_chd_drv_p1_layer_1 = fl_chd_drv_p1
                    # # part 2: (a_1 * (y1)^{b_1 - 1} )
                    # fl_chd_drv_p2 = fl_chd_shr * (fl_chd_qty)**(fl_prt_pwr-1)
                    # # combine
                    # fl_chd_drv = fl_chd_drv_p1 * fl_chd_drv_p2
                    # fl_chd_drc = fl_prt_drc * fl_chd_drv

                    # sni: s(share)n(nested)i(intercept-numerator-or-denominator)
                    fl_chd_sni = (fl_prt_drc * fl_chd_drv_p1 *
                                  fl_chd_shr) / fl_chd_drv_p1_layer_1

                    if verbose_debug:
                        print(
                            f'{fl_chd_drv=:.4f}, {fl_chd_drc=:.4f}, {fl_chd_shc=:.4f}, {fl_chd_sni=:.4f}')

                # Add to tree
                dc_ces_flat[it_chd_key]['drv'] = fl_chd_drv
                dc_ces_flat[it_chd_key]['drc'] = fl_chd_drc
                dc_ces_flat[it_chd_key]['shc'] = fl_chd_shc
                dc_ces_flat[it_chd_key]['sni'] = fl_chd_sni

    if verbose:
        print('d-547654 name: dc_ces_flat')
        pprint.pprint(dc_ces_flat, width=2)

    return dc_ces_flat


if __name__ == "__main__":

    import prjlecm.input.cme_inpt_simu_demand as cme_inpt_simu_demand

    ls_bl_simu_q = [True]
    for bl_simu_q in ls_bl_simu_q:

        # A. Simulates Nested-ces, with share, power, an possiblity quantities
        # elasticity of substitution homogeneous within layer
        dc_dc_ces_nested = cme_inpt_simu_demand.cme_simu_demand_params_ces_nested(
            ar_it_chd_tre=[2, 2], ar_it_occ_lyr=[2],
            fl_power_min=0.8,
            fl_power_max=0.8,
            it_seed=222,
            bl_simu_q=bl_simu_q,
            verbose=True, verbose_debug=False)
        dc_ces_flat = dc_dc_ces_nested['dc_ces_flat']

        # B. Generate higher layer quantities, evaluate ces production
        # output dc_ces_flat is the same dict as the input, but with updated info
        if bl_simu_q:
            dc_ces_flat = cme_prod_ces_nest_output(
                dc_ces_flat, verbose=True, verbose_debug=True)

        # C. Given quantities at all levels, compute MPL for nodes
        dc_ces_flat = cme_prod_ces_nest_mpl(
            dc_ces_flat, verbose=True, verbose_debug=True)

        # testing when power=power at all layers, are the share ratio
        # consistent with the drc ratio
        if bl_simu_q:
            ls_it_numerator = [1, 1]
            ls_it_denominator = [2, 4]
            for it_nume, it_deno in zip(ls_it_numerator, ls_it_denominator):
                fl_within_nest_rela_drc = dc_ces_flat[it_nume]['sni'] / \
                                          dc_ces_flat[it_deno]['sni']
                fl_within_nest_rela_shr = dc_ces_flat[it_nume]['shc'] / \
                                          dc_ces_flat[it_deno]['shc']
                print(f'{it_nume=} and {it_deno=}')
                print(f'{fl_within_nest_rela_drc=} and {fl_within_nest_rela_shr=}')
