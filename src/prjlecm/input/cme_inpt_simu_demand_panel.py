"""Generate Nested-CES Demand-side dict for Panel with Polynomial Parameters
The :mod:`prjlecm.input.cme_inpt_simu_demand_panel` generated a nested dictionary storing all CES structure
and parameters for several years. 

This dictionary is in support of the dc_ces generated by `cme_inpt_simu_demand`. Rather
than generating random parameters, the structure here allows the share parameters to be
based on specific functions.

Parameters can be random, based on polynomial within year across groups, or polynomial
across years within group. 

Includes method :func:`cme_`, 
"""

# Consider the information below as adding additional variables, additional
# key/value pairs to the dictionary and resulting table. 
# Specify a dictionary with all needed information:
# prm = parameters
# typ = "val" or "tms" or "shr", value only, timeseries or within-time-share
# log = if log(param) is polynomial or param is polynomial
# pcf = polynomial coefficients, polynomial order determined from prm len
# obs = observable values matching to each child of next
# nrm = normalize, rescale to sum to 1 
# res = residual computed as diff of 1 and sum of defined
# val = this is whatever is the additional observable supposed to be used
#   to do the polynomial. 

# Initial thought:
# # specify values for lowest layer children
# dc_param_obs = {
#     1: {"typ": "val", "val" : 25},
#     2: {"typ": "val", "val" : 26},
#     3: {"typ": "val", "val" : 27}
# }
# # specified by parent
# # when specifying by parent, equation applies too all children
# dc_param_poly = {
#     25: {
#         "typ": "shr",
#         "log": True,
#         "prm": [1.2, 0.2],
#         "nrm": True
#     }
# }
# # specified by node
# # equation applies to one child, inter-temporal
# # evaluate only at the specific val
# # For the children in the same nest without parameter
# # specification, will be equal to residual diff
# # If all children defined as below, then will be normalized
# # to 1
# dc_param_time_series_poly = {
#     31: {
#         "typ": "tms",
#         "log": True,
#         "prm": [1.2, 0.2, 0.1],
#         "nrm": False,
#         "val": 1995,
#         "nrm": False,
#         "res": True 
#     }
# }
# 
# Additional thoughts:
# - Limit the number of potential columns in dataframe
# - Do not generalize beyond polynomial
# 
# Each key_node has:
# - prm: polynomial parameter, polynomial parameter array
# - ply: polynomial value layer, polynomial value to be multiplied by value at which layer
# - pex: polynomial exponential, whether to exponentiate i
# -
# - If the last element of each nest has no value specified, that is the residual
# used when parameters are over time
# whether to divide by common coefficient (actually, this is useless)
# parameters should be picked that they will summ up to one when multiplied. 
# A number of key-nodes could share the identical information
# Note the only goal here is to generate the share parameters. 

# What is the goal here?
# The simple goal, is, I need to specify, for each layer,
# What is the polynomial to be used for the layer within the layer,
# Do the different children within each sub-nest share the parameters?
# Assume that people do. So given [4,3,2], there are at the bottom layer, 4 children each
# subnest, we can specificy, for all of these, min and max values for the polynomial parameters
# to be randomly drawn, along with seeds.
# Actually, to keep things simple, just s

# psd = seeds for simulating parameter to keep parameter the same

# pex = exponentiate polynomials

# drawn for each
# prs = polynomial residual, true or false, if residual, always last index
# parameters to all children within nest, but with different observable values from nvl. If
# base-group = which index is the base group, the residual group, psh is false also means that this is
# likely a binary thing, so the base index is always residual

import numpy as np

# The structure below is for generating parameters:
# 1. Generate corresponding polynomials
# 2. Generating corresponding share parameter values.
ar_it_chd_tre = [2, 2, 3]

# prd = polynomial order, prd=0 0th order, not a function of observable, intercept fixed.
#   Note that the intercept term for polynomials id not identified, it is normalized to 1
#   in order to get things summed correctly to 1. So can not specify polynomial order of
#   0, at least it is 1, because the 0th parameter is not free.
# psc = polynomial scaling of the different parameters, this is the ratio of parameters,
# psd = polynomial seed

# plr = data from which layer to use, if None, this is a constant, prd = 0

# - If we have a time-invariant constant in layer 1 without nesting. pin=FALSE, 
# if (pin is False and pic is False): different polynomial for each child at layer, polynomial
#   might be over different years (across the CES-nests which are year specific)
#   e.g., different age share at each occupation, each occ/age share follows own time trends
# if (pin is False and pic is TRUE): different polynomials for each sub-nest, same within
#   e.g., different age-specific share parameters for occupations, age are children in subnests
#       within each sub-nest, age-specific parameters follow the same polynomial
# if (pin is True and pic is False): Same parameters across sub-nests, but differ within
#   e.g., same age shares for all occ, each age share follows own polynomial time trends
# if (pin is True and pic is True): all parameters shared
#   e.g., age share elasticity the same across subnest, and following polynomial across ages.
# pin = polynomial shared across subnests
# pic = polynomial shared across children of each subnest, share differ due to value at child

# The above discussion is too general, only need to have something that works with the immediate situation here:
# - to generate "constant"-term shares that are not functions of observations, different for each child within layer
#       occupation share and also gender shares are of this nature
#       each layer has a number of subnest and a number children falling into these subnests.
#       draw randomly N parameters, make sure they sum up to 1. 
# - to generate polynomial based parameter, where draw different polynomials for each subnest, 

# Fully worked out the structure
# At each layer, think about:
# - rows: subnests
# - cols: children in subnests
# - value: each cell value contains an array of polynomial coefficients or any order
# 
# prd, psc determine the polynomial coefficients, and plr determines what to be multiplied by
# 
# prw, pcl determines whether coefficients differ across rows (subnests) or columns (children), 
#   can be none is fthere are no subnetss
# 
# This structure accomandates I think any and all situations. 
# 
# one output from this exercise, is the multi-dimensional structure of this throughout layers.
#

# layers: (0) year top; (1) occupation; (2) gender; (3) age
# We have several situations:
#   - A. has 2 elements within nest
#       - (1) constant share across time:
#       - (2) different share across time following polynomial
#   - B. has >2 elements within nest
#       - (1) constant share across time, but within time follow polynomial across children, same as A(1)
#       - (2) different share across time, same as A(2), each term own polynomial
#   in A(2) and B(2), the first element of child is 1 in all periods. And polynomial
#   to be specified has a free intercept
#   in A(1) and B(1), polynomial do not need to specify intercept
#   we don't actually have B(2), situations usually just A(1), A(2) and B(1)

# PLR should alwasy be for current or higher ranked layer (lover value)

# if RPW=False and PLR=node layer:
#   So when each row's parameter is different, this means each sub-nest
#   will have different parameters.
# if RPW=False and PLR=higher node layer:
#   If the parameters rely on current layer node values, each node will
#   have its own parametesr. If they rely on higher layer node values.
# each node within each subset will have shared values.
# PCL parameter should not be used, there seems to be no effective ways
# of using it, so it should not matter. not sure what it is there.
dc_chd_gen_shr = {"prd": [0, 3, 1, 3],
                  "psc": [5e0, 1e1, 1e1, 1e1],
                  "psd": [123, 456, 789, 101],
                  "plr": [0, 0, 2, 3],
                  "prw": [None, None, True, True],
                  "pcl": [None, True, False, False],
                  "pex": [False, False, True, True]}

ar_it_chd_tre_wth_zr = [1] + ar_it_chd_tre

verbose = True
verbose_debug = True
# Loop over layers, from the tip of the pyramid to the base
for it_layer, it_chd_tre in enumerate(ar_it_chd_tre_wth_zr):

    if verbose_debug:
        print(f'{it_layer=} and {it_chd_tre=}')

    # Not the total number of children at layer, but the total
    # number of subnests.
    it_nests_at_layer = int(np.prod(np.array(ar_it_chd_tre_wth_zr[0:it_layer])))
    it_child_pernest_at_layer = it_chd_tre
    print(f'{it_nests_at_layer=}')

    # Get layer-specific parameters
    it_prd = dc_chd_gen_shr["prd"][it_layer]
    fl_psc = dc_chd_gen_shr["psc"][it_layer]
    it_psd = dc_chd_gen_shr["psd"][it_layer]
    bl_prw = dc_chd_gen_shr["prw"][it_layer]
    bl_pcl = dc_chd_gen_shr["pcl"][it_layer]
    if verbose_debug:
        print(f'd-43605 dc_chd_gen_shr')
        print(f'{it_prd=}, {fl_psc=}, {it_psd=}')
        print(f'{bl_prw=}, {bl_pcl=}')

    # Draw seeds parameters
    # it_psd is the seed for drawing seeds
    np.random.seed(it_psd)
    if bl_prw is True and bl_pcl is True:
        # each sub-nest parameters differ, each child follows different polynomial
        mt_it_seeds = np.random.randint(
            low=1, high=1e6, size=[it_nests_at_layer, it_child_pernest_at_layer])
    elif bl_prw is True:
        # Each sub-nest follows own polynomial, same polynomial within next across children
        # bl_pcl is false
        mt_it_seeds = np.random.randint(
            low=1, high=1e6, size=[it_nests_at_layer, 1])
        mt_it_seeds = np.tile(mt_it_seeds, (1,it_child_pernest_at_layer))
    elif bl_pcl is True:
        # each child follows the same polynomial
        # bl_prw is False
        mt_it_seeds = np.random.randint(
            low=1, high=1e6, size=[1, it_child_pernest_at_layer])
        mt_it_seeds = np.tile(mt_it_seeds, (it_nests_at_layer, 1))
    else:
        # This is all other cases where uniform draws acoss children
        mt_it_seeds = np.random.randint(
            low=1, high=1e6, size=[1, 1])
        mt_it_seeds = np.tile(mt_it_seeds, (it_nests_at_layer, it_child_pernest_at_layer))
    if verbose_debug:
        print(f'd-43605 mt_it_seeds, rows=nests, cols=children-per-nest')
        print(mt_it_seeds)

    # Generate random parameters
    # + 1 for 2nd order polynomial to have 3 coefficients.
    # wi = with intercept
    it_prd_wi = it_prd + 1
    mn_fl_poly = np.empty([it_prd_wi, it_nests_at_layer,it_child_pernest_at_layer])
    for it_row in np.arange(it_nests_at_layer):
        for it_col in np.arange(it_child_pernest_at_layer):

            # set seed for drawing polynomial coefficients
            np.random.seed(mt_it_seeds[it_row, it_col])
            # Draw polynomial coefficients
            ar_poly_coef = np.random.rand(it_prd_wi)-0.5

            # Adjust coefficients
            ar_fl_coef_adj = [fl_psc**i for i in np.arange(it_prd_wi)]
            ar_poly_coef_adj = ar_poly_coef/ar_fl_coef_adj
            # print(f'{ar_fl_rand=}\n{ar_fl_poly_coef=}')

            # Store adjusted coefficients
            mn_fl_poly[:, it_row, it_col] = ar_poly_coef_adj

    if verbose_debug:
        print(f'd-43605 mn_fl_poly, mat=poly, rows=nests, cols=children-per-nest')
        print(mn_fl_poly)
        print('\n')

    # Adjust coefficients
    # ar_fl_coef_adj = [fl_psc**i for i in np.arange(it_prd)]
    # ar_fl_poly_coef = ar_fl_rand/ar_fl_coef_adj
    # print(f'{ar_fl_rand=}\n{ar_fl_poly_coef=}')
    #
    # # Layer
    # it_plr = dc_chd_gen_shr["plr"][it_layer]
    # print(f'{it_plr=}')
    #
# output, key by key, row by row, polynomial coefficients, observation, and for several years
# dc_key_node_shr_poly = {
#     31: {
#         "prm" : [1e1, 1e0, -1e-2],
#         "ply" : 2,
#         "pex" : True
#     }
# }
#

# to generate the auxillary dictionary, for each layer, specify:
# 1. add val_num and val_var and val_lab, equivalent to name of variable, and value_lab, string description of the variable if additional
# descriptions are helpful, these are added during the initial dict generation process. And the val at the top is year value for example. 
# vld = variable.value data, vlv = value variable, vlb = variable label
# vld = "25", vlv = "age", vlb = "age in years"
# 2. type
# 2. min value, max value
# 2.

# So seems like I have a very good undersandng of how to normalize
# and do share parameters within period based on polynomial. But
# I do not understand, have a good strategy for dealing with this
# across periods.
# So in principle, just need to specify one of three types of parameters
# one belongs to:

# (1) Differ across subnests, how to just draw all random parameters.
# both column and row all different seeds, and have 0th order polynomial
# just draw constants: prw and pcl both true, lyr = 0, actually, just prw true is sufficient.
#
# (2) Differ across subnets, each subnest within follows polynoimal
# normalized so that intercept = 1, and value adjusted so first index node
# has x-value of 0: prw is true, pcl is false, lyr >= 0, even 0th order
# is fine that means all parameters are the same, at all nodes.
#
# (3) So the question is how to properly normalize values so that
# estimation can proceed with the right degree of freedom? when we
# have polynomial over multiple years, for one of the node, the other
# node is suppose to be residual, this should be generalizabl to cases
# where there are more than one subnest at layer, and more than two nodes
# per subnest, but at least should work for the case where there is
# one subnest and 2 nodes in the subnest at the layer.
# A: The solution is the following, in addition to drawing the polynomial
# need to draw bounds for the polynomial that is equal to the max and min
# values of the polynomial. So we draw two values between 0 and 1 randomly
# use the lower and higher values as the bounds, respectively. Then rescale
# the polynomial so that its interecept starting value is at the min, and
# it reaches the max somewhere between start and end. For this,
# pcl is true, lyr is at the peak of the pyramid. prw can be true or can be
# false. But this problem is trickier now, because the simulation
# requires information from all other nodes. So these need to be provided
# in addition to the current value, but also the min and max values. Actually, just prol
# true is suffiient.
#